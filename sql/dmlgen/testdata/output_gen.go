/*
Sniperkit-Bot
- Status: analyzed
*/

// Auto generated via github.com/sniperkit/snk.fork.corestoreio-pkg/sql/dmlgen

package testdata

import (
	"encoding/json"
	"time"

	"github.com/corestoreio/errors"

	"github.com/sniperkit/snk.fork.corestoreio-pkg/sql/ddl"
	"github.com/sniperkit/snk.fork.corestoreio-pkg/sql/dml"
)

// NewTables returns a goified version of the MySQL/MariaDB table schema for the
// tables: [core_config_data customer_entity dmlgen_types]
// Auto generated by dmlgen.
func NewTables(opts ...ddl.TableOption) (*ddl.Tables, error) {
	tm, err := ddl.NewTables(
		ddl.WithTable("core_config_data", ddl.Columns{
			&ddl.Column{Field: "config_id", Pos: 1, Null: "NO", DataType: "int", Precision: dml.MakeNullInt64(10), Scale: dml.MakeNullInt64(0), ColumnType: "int(10) unsigned", Key: "PRI", Extra: "auto_increment", Comment: "Config Id", StructTag: "json:\"config_id,omitempty\""},
			&ddl.Column{Field: "scope", Pos: 2, Default: dml.MakeNullString("'default'"), Null: "NO", DataType: "varchar", CharMaxLength: dml.MakeNullInt64(8), ColumnType: "varchar(8)", Key: "MUL", Comment: "Config Scope", StructTag: "json:\"scope,omitempty\""},
			&ddl.Column{Field: "scope_id", Pos: 3, Default: dml.MakeNullString("0"), Null: "NO", DataType: "int", Precision: dml.MakeNullInt64(10), Scale: dml.MakeNullInt64(0), ColumnType: "int(11)", Comment: "Config Scope Id", StructTag: "json:\"scope_id\" xml:\"scope_id\""},
			&ddl.Column{Field: "path", Pos: 4, Default: dml.MakeNullString("'general'"), Null: "NO", DataType: "varchar", CharMaxLength: dml.MakeNullInt64(255), ColumnType: "varchar(255)", Comment: "Config Path", Aliases: []string{"storage_location", "config_directory"}, Uniquified: true, StructTag: "json:\"x_path\" xml:\"y_path\""},
			&ddl.Column{Field: "value", Pos: 5, Default: dml.MakeNullString("NULL"), Null: "YES", DataType: "text", CharMaxLength: dml.MakeNullInt64(65535), ColumnType: "text", Comment: "Config Value", StructTag: "json:\"value,omitempty\""},
		}...),
		ddl.WithTable("customer_entity", ddl.Columns{
			&ddl.Column{Field: "entity_id", Pos: 1, Null: "NO", DataType: "int", Precision: dml.MakeNullInt64(10), Scale: dml.MakeNullInt64(0), ColumnType: "int(10) unsigned", Key: "PRI", Extra: "auto_increment", Comment: "Entity Id", Aliases: []string{"customer_id", "parent_id"}},
			&ddl.Column{Field: "website_id", Pos: 2, Null: "YES", DataType: "smallint", Precision: dml.MakeNullInt64(5), Scale: dml.MakeNullInt64(0), ColumnType: "smallint(5) unsigned", Key: "MUL", Comment: "Website Id"},
			&ddl.Column{Field: "email", Pos: 3, Null: "YES", DataType: "varchar", CharMaxLength: dml.MakeNullInt64(255), ColumnType: "varchar(255)", Key: "MUL", Comment: "Email"},
			&ddl.Column{Field: "group_id", Pos: 4, Default: dml.MakeNullString("0"), Null: "NO", DataType: "smallint", Precision: dml.MakeNullInt64(5), Scale: dml.MakeNullInt64(0), ColumnType: "smallint(5) unsigned", Comment: "Group Id"},
			&ddl.Column{Field: "increment_id", Pos: 5, Null: "YES", DataType: "varchar", CharMaxLength: dml.MakeNullInt64(50), ColumnType: "varchar(50)", Comment: "Increment Id"},
			&ddl.Column{Field: "store_id", Pos: 6, Default: dml.MakeNullString("0"), Null: "YES", DataType: "smallint", Precision: dml.MakeNullInt64(5), Scale: dml.MakeNullInt64(0), ColumnType: "smallint(5) unsigned", Key: "MUL", Comment: "Store Id"},
			&ddl.Column{Field: "created_at", Pos: 7, Default: dml.MakeNullString("current_timestamp()"), Null: "NO", DataType: "timestamp", ColumnType: "timestamp", Comment: "Created At"},
			&ddl.Column{Field: "updated_at", Pos: 8, Default: dml.MakeNullString("current_timestamp()"), Null: "NO", DataType: "timestamp", ColumnType: "timestamp", Extra: "on update current_timestamp()", Comment: "Updated At"},
			&ddl.Column{Field: "is_active", Pos: 9, Default: dml.MakeNullString("1"), Null: "NO", DataType: "smallint", Precision: dml.MakeNullInt64(5), Scale: dml.MakeNullInt64(0), ColumnType: "smallint(5) unsigned", Comment: "Is Active"},
			&ddl.Column{Field: "disable_auto_group_change", Pos: 10, Default: dml.MakeNullString("0"), Null: "NO", DataType: "smallint", Precision: dml.MakeNullInt64(5), Scale: dml.MakeNullInt64(0), ColumnType: "smallint(5) unsigned", Comment: "Disable automatic group change based on VAT ID"},
			&ddl.Column{Field: "created_in", Pos: 11, Null: "YES", DataType: "varchar", CharMaxLength: dml.MakeNullInt64(255), ColumnType: "varchar(255)", Comment: "Created From"},
			&ddl.Column{Field: "prefix", Pos: 12, Null: "YES", DataType: "varchar", CharMaxLength: dml.MakeNullInt64(40), ColumnType: "varchar(40)", Comment: "Name Prefix"},
			&ddl.Column{Field: "firstname", Pos: 13, Null: "YES", DataType: "varchar", CharMaxLength: dml.MakeNullInt64(255), ColumnType: "varchar(255)", Key: "MUL", Comment: "First Name"},
			&ddl.Column{Field: "middlename", Pos: 14, Null: "YES", DataType: "varchar", CharMaxLength: dml.MakeNullInt64(255), ColumnType: "varchar(255)", Comment: "Middle Name/Initial"},
			&ddl.Column{Field: "lastname", Pos: 15, Null: "YES", DataType: "varchar", CharMaxLength: dml.MakeNullInt64(255), ColumnType: "varchar(255)", Key: "MUL", Comment: "Last Name"},
			&ddl.Column{Field: "suffix", Pos: 16, Null: "YES", DataType: "varchar", CharMaxLength: dml.MakeNullInt64(40), ColumnType: "varchar(40)", Comment: "Name Suffix"},
			&ddl.Column{Field: "dob", Pos: 17, Null: "YES", DataType: "date", ColumnType: "date", Comment: "Date of Birth"},
			&ddl.Column{Field: "password_hash", Pos: 18, Null: "YES", DataType: "varchar", CharMaxLength: dml.MakeNullInt64(128), ColumnType: "varchar(128)", Comment: "Password_hash"},
			&ddl.Column{Field: "rp_token", Pos: 19, Null: "YES", DataType: "varchar", CharMaxLength: dml.MakeNullInt64(128), ColumnType: "varchar(128)", Comment: "Reset password token"},
			&ddl.Column{Field: "rp_token_created_at", Pos: 20, Null: "YES", DataType: "datetime", ColumnType: "datetime", Comment: "Reset password token creation time"},
			&ddl.Column{Field: "default_billing", Pos: 21, Null: "YES", DataType: "int", Precision: dml.MakeNullInt64(10), Scale: dml.MakeNullInt64(0), ColumnType: "int(10) unsigned", Comment: "Default Billing Address"},
			&ddl.Column{Field: "default_shipping", Pos: 22, Null: "YES", DataType: "int", Precision: dml.MakeNullInt64(10), Scale: dml.MakeNullInt64(0), ColumnType: "int(10) unsigned", Comment: "Default Shipping Address"},
			&ddl.Column{Field: "taxvat", Pos: 23, Null: "YES", DataType: "varchar", CharMaxLength: dml.MakeNullInt64(50), ColumnType: "varchar(50)", Comment: "Tax/VAT Number"},
			&ddl.Column{Field: "confirmation", Pos: 24, Null: "YES", DataType: "varchar", CharMaxLength: dml.MakeNullInt64(64), ColumnType: "varchar(64)", Comment: "Is Confirmed"},
			&ddl.Column{Field: "gender", Pos: 25, Null: "YES", DataType: "smallint", Precision: dml.MakeNullInt64(5), Scale: dml.MakeNullInt64(0), ColumnType: "smallint(5) unsigned", Comment: "Gender"},
			&ddl.Column{Field: "failures_num", Pos: 26, Default: dml.MakeNullString("0"), Null: "YES", DataType: "smallint", Precision: dml.MakeNullInt64(5), Scale: dml.MakeNullInt64(0), ColumnType: "smallint(6)", Comment: "Failure Number"},
			&ddl.Column{Field: "first_failure", Pos: 27, Null: "YES", DataType: "timestamp", ColumnType: "timestamp", Comment: "First Failure"},
			&ddl.Column{Field: "lock_expires", Pos: 28, Null: "YES", DataType: "timestamp", ColumnType: "timestamp", Comment: "Lock Expiration Date"},
		}...),
		ddl.WithTable("dmlgen_types", ddl.Columns{
			&ddl.Column{Field: "id", Pos: 1, Null: "NO", DataType: "int", Precision: dml.MakeNullInt64(10), Scale: dml.MakeNullInt64(0), ColumnType: "int(11)", Key: "PRI", Extra: "auto_increment", StructTag: "json:\"id,omitempty\" "},
			&ddl.Column{Field: "col_bigint_1", Pos: 2, Null: "YES", DataType: "bigint", Precision: dml.MakeNullInt64(19), Scale: dml.MakeNullInt64(0), ColumnType: "bigint(20)", StructTag: "json:\"col_bigint_1,omitempty\" "},
			&ddl.Column{Field: "col_bigint_2", Pos: 3, Default: dml.MakeNullString("0"), Null: "NO", DataType: "bigint", Precision: dml.MakeNullInt64(19), Scale: dml.MakeNullInt64(0), ColumnType: "bigint(20)", StructTag: "json:\"col_bigint_2,omitempty\" "},
			&ddl.Column{Field: "col_bigint_3", Pos: 4, Null: "YES", DataType: "bigint", Precision: dml.MakeNullInt64(20), Scale: dml.MakeNullInt64(0), ColumnType: "bigint(20) unsigned", StructTag: "json:\"col_bigint_3,omitempty\" "},
			&ddl.Column{Field: "col_bigint_4", Pos: 5, Default: dml.MakeNullString("0"), Null: "NO", DataType: "bigint", Precision: dml.MakeNullInt64(20), Scale: dml.MakeNullInt64(0), ColumnType: "bigint(20) unsigned", StructTag: "json:\"col_bigint_4,omitempty\" "},
			&ddl.Column{Field: "col_blob", Pos: 6, Null: "YES", DataType: "blob", CharMaxLength: dml.MakeNullInt64(65535), ColumnType: "blob", Uniquified: true, StructTag: "json:\"col_blob,omitempty\" "},
			&ddl.Column{Field: "col_date_1", Pos: 7, Null: "YES", DataType: "date", ColumnType: "date", StructTag: "json:\"col_date_1,omitempty\" "},
			&ddl.Column{Field: "col_date_2", Pos: 8, Default: dml.MakeNullString("'0000-00-00'"), Null: "NO", DataType: "date", ColumnType: "date", Uniquified: true, StructTag: "json:\"col_date_2,omitempty\" "},
			&ddl.Column{Field: "col_datetime_1", Pos: 9, Null: "YES", DataType: "datetime", ColumnType: "datetime", StructTag: "json:\"col_datetime_1,omitempty\" "},
			&ddl.Column{Field: "col_datetime_2", Pos: 10, Default: dml.MakeNullString("'0000-00-00 00:00:00'"), Null: "NO", DataType: "datetime", ColumnType: "datetime", StructTag: "json:\"col_datetime_2,omitempty\" "},
			&ddl.Column{Field: "col_decimal_10_0", Pos: 11, Null: "YES", DataType: "decimal", Precision: dml.MakeNullInt64(10), Scale: dml.MakeNullInt64(0), ColumnType: "decimal(10,0) unsigned", StructTag: "json:\"col_decimal_10_0,omitempty\" "},
			&ddl.Column{Field: "col_decimal_12_4", Pos: 12, Null: "YES", DataType: "decimal", Precision: dml.MakeNullInt64(12), Scale: dml.MakeNullInt64(4), ColumnType: "decimal(12,4)", StructTag: "json:\"col_decimal_12_4,omitempty\" "},
			&ddl.Column{Field: "price_12_4a", Pos: 13, Null: "YES", DataType: "decimal", Precision: dml.MakeNullInt64(12), Scale: dml.MakeNullInt64(4), ColumnType: "decimal(12,4)", StructTag: "json:\"price_12_4a,omitempty\" "},
			&ddl.Column{Field: "price_12_4b", Pos: 14, Default: dml.MakeNullString("0.0000"), Null: "NO", DataType: "decimal", Precision: dml.MakeNullInt64(12), Scale: dml.MakeNullInt64(4), ColumnType: "decimal(12,4)", StructTag: "json:\"price_12_4b,omitempty\" "},
			&ddl.Column{Field: "col_decimal_12_3", Pos: 15, Default: dml.MakeNullString("0.000"), Null: "NO", DataType: "decimal", Precision: dml.MakeNullInt64(12), Scale: dml.MakeNullInt64(3), ColumnType: "decimal(12,3)", StructTag: "json:\"col_decimal_12_3,omitempty\" "},
			&ddl.Column{Field: "col_decimal_20_6", Pos: 16, Default: dml.MakeNullString("0.000000"), Null: "NO", DataType: "decimal", Precision: dml.MakeNullInt64(20), Scale: dml.MakeNullInt64(6), ColumnType: "decimal(20,6)", StructTag: "json:\"col_decimal_20_6,omitempty\" "},
			&ddl.Column{Field: "col_decimal_24_12", Pos: 17, Default: dml.MakeNullString("0.000000000000"), Null: "NO", DataType: "decimal", Precision: dml.MakeNullInt64(24), Scale: dml.MakeNullInt64(12), ColumnType: "decimal(24,12)", StructTag: "json:\"col_decimal_24_12,omitempty\" "},
			&ddl.Column{Field: "col_float", Pos: 18, Default: dml.MakeNullString("1"), Null: "NO", DataType: "float", Precision: dml.MakeNullInt64(12), ColumnType: "float", StructTag: "json:\"col_float,omitempty\" "},
			&ddl.Column{Field: "col_int_1", Pos: 19, Null: "YES", DataType: "int", Precision: dml.MakeNullInt64(10), Scale: dml.MakeNullInt64(0), ColumnType: "int(10)", Uniquified: true, StructTag: "json:\"col_int_1,omitempty\" "},
			&ddl.Column{Field: "col_int_2", Pos: 20, Default: dml.MakeNullString("0"), Null: "NO", DataType: "int", Precision: dml.MakeNullInt64(10), Scale: dml.MakeNullInt64(0), ColumnType: "int(10)", Uniquified: true, StructTag: "json:\"col_int_2,omitempty\" "},
			&ddl.Column{Field: "col_int_3", Pos: 21, Null: "YES", DataType: "int", Precision: dml.MakeNullInt64(10), Scale: dml.MakeNullInt64(0), ColumnType: "int(10) unsigned", StructTag: "json:\"col_int_3,omitempty\" "},
			&ddl.Column{Field: "col_int_4", Pos: 22, Default: dml.MakeNullString("0"), Null: "NO", DataType: "int", Precision: dml.MakeNullInt64(10), Scale: dml.MakeNullInt64(0), ColumnType: "int(10) unsigned", StructTag: "json:\"col_int_4,omitempty\" "},
			&ddl.Column{Field: "col_longtext_1", Pos: 23, Null: "YES", DataType: "longtext", CharMaxLength: dml.MakeNullInt64(4294967295), ColumnType: "longtext", StructTag: "json:\"col_longtext_1,omitempty\" "},
			&ddl.Column{Field: "col_longtext_2", Pos: 24, Default: dml.MakeNullString("''"), Null: "NO", DataType: "longtext", CharMaxLength: dml.MakeNullInt64(4294967295), ColumnType: "longtext", Uniquified: true, StructTag: "json:\"col_longtext_2,omitempty\" "},
			&ddl.Column{Field: "col_mediumblob", Pos: 25, Null: "YES", DataType: "mediumblob", CharMaxLength: dml.MakeNullInt64(16777215), ColumnType: "mediumblob", StructTag: "json:\"col_mediumblob,omitempty\" "},
			&ddl.Column{Field: "col_mediumtext_1", Pos: 26, Null: "YES", DataType: "mediumtext", CharMaxLength: dml.MakeNullInt64(16777215), ColumnType: "mediumtext", StructTag: "json:\"col_mediumtext_1,omitempty\" "},
			&ddl.Column{Field: "col_mediumtext_2", Pos: 27, Default: dml.MakeNullString("''"), Null: "NO", DataType: "mediumtext", CharMaxLength: dml.MakeNullInt64(16777215), ColumnType: "mediumtext", StructTag: "json:\"col_mediumtext_2,omitempty\" "},
			&ddl.Column{Field: "col_smallint_1", Pos: 28, Null: "YES", DataType: "smallint", Precision: dml.MakeNullInt64(5), Scale: dml.MakeNullInt64(0), ColumnType: "smallint(5)", StructTag: "json:\"col_smallint_1,omitempty\" "},
			&ddl.Column{Field: "col_smallint_2", Pos: 29, Default: dml.MakeNullString("0"), Null: "NO", DataType: "smallint", Precision: dml.MakeNullInt64(5), Scale: dml.MakeNullInt64(0), ColumnType: "smallint(5)", StructTag: "json:\"col_smallint_2,omitempty\" "},
			&ddl.Column{Field: "col_smallint_3", Pos: 30, Null: "YES", DataType: "smallint", Precision: dml.MakeNullInt64(5), Scale: dml.MakeNullInt64(0), ColumnType: "smallint(5) unsigned", StructTag: "json:\"col_smallint_3,omitempty\" "},
			&ddl.Column{Field: "col_smallint_4", Pos: 31, Default: dml.MakeNullString("0"), Null: "NO", DataType: "smallint", Precision: dml.MakeNullInt64(5), Scale: dml.MakeNullInt64(0), ColumnType: "smallint(5) unsigned", StructTag: "json:\"col_smallint_4,omitempty\" "},
			&ddl.Column{Field: "has_smallint_5", Pos: 32, Default: dml.MakeNullString("0"), Null: "NO", DataType: "smallint", Precision: dml.MakeNullInt64(5), Scale: dml.MakeNullInt64(0), ColumnType: "smallint(5) unsigned", Uniquified: true, StructTag: "json:\"has_smallint_5,omitempty\" "},
			&ddl.Column{Field: "is_smallint_5", Pos: 33, Null: "YES", DataType: "smallint", Precision: dml.MakeNullInt64(5), Scale: dml.MakeNullInt64(0), ColumnType: "smallint(5)", StructTag: "json:\"is_smallint_5,omitempty\" "},
			&ddl.Column{Field: "col_text", Pos: 34, Null: "YES", DataType: "text", CharMaxLength: dml.MakeNullInt64(65535), ColumnType: "text", StructTag: "json:\"col_text,omitempty\" "},
			&ddl.Column{Field: "col_timestamp_1", Pos: 35, Default: dml.MakeNullString("current_timestamp()"), Null: "NO", DataType: "timestamp", ColumnType: "timestamp", StructTag: "json:\"col_timestamp_1,omitempty\" "},
			&ddl.Column{Field: "col_timestamp_2", Pos: 36, Null: "YES", DataType: "timestamp", ColumnType: "timestamp", StructTag: "json:\"col_timestamp_2,omitempty\" "},
			&ddl.Column{Field: "col_tinyint_1", Pos: 37, Default: dml.MakeNullString("0"), Null: "NO", DataType: "tinyint", Precision: dml.MakeNullInt64(3), Scale: dml.MakeNullInt64(0), ColumnType: "tinyint(1)", StructTag: "json:\"col_tinyint_1,omitempty\" "},
			&ddl.Column{Field: "col_varchar_1", Pos: 38, Default: dml.MakeNullString("'0'"), Null: "NO", DataType: "varchar", CharMaxLength: dml.MakeNullInt64(1), ColumnType: "varchar(1)", StructTag: "json:\"col_varchar_1,omitempty\" "},
			&ddl.Column{Field: "col_varchar_100", Pos: 39, Null: "YES", DataType: "varchar", CharMaxLength: dml.MakeNullInt64(100), ColumnType: "varchar(100)", StructTag: "json:\"col_varchar_100,omitempty\" "},
			&ddl.Column{Field: "col_varchar_16", Pos: 40, Default: dml.MakeNullString("'de_DE'"), Null: "NO", DataType: "varchar", CharMaxLength: dml.MakeNullInt64(16), ColumnType: "varchar(16)", StructTag: "json:\"col_varchar_16,omitempty\" "},
			&ddl.Column{Field: "col_char_1", Pos: 41, Null: "YES", DataType: "char", CharMaxLength: dml.MakeNullInt64(21), ColumnType: "char(21)", StructTag: "json:\"col_char_1,omitempty\" "},
			&ddl.Column{Field: "col_char_2", Pos: 42, Default: dml.MakeNullString("'xchar'"), Null: "NO", DataType: "char", CharMaxLength: dml.MakeNullInt64(17), ColumnType: "char(17)", StructTag: "json:\"col_char_2,omitempty\" "},
		}...),
	)
	if err != nil {
		return nil, errors.WithStack(err)
	}
	if err := tm.Options(opts...); err != nil {
		return nil, errors.WithStack(err)
	}
	return tm, nil
}

// CoreConfigData represents a single row for DB table `core_config_data`.
// Auto generated.
type CoreConfigData struct {
	ConfigID uint64         `json:"config_id,omitempty"`     // config_id int(10) unsigned NOT NULL PRI  auto_increment "Config Id"
	Scope    string         `json:"scope,omitempty"`         // scope varchar(8) NOT NULL MUL DEFAULT ''default''  "Config Scope"
	ScopeID  int64          `json:"scope_id" xml:"scope_id"` // scope_id int(11) NOT NULL  DEFAULT '0'  "Config Scope Id"
	Path     string         `json:"x_path" xml:"y_path"`     // path varchar(255) NOT NULL  DEFAULT ''general''  "Config Path"
	Value    dml.NullString `json:"value,omitempty"`         // value text NULL  DEFAULT 'NULL'  "Config Value"
}

// NewCoreConfigData creates a new pointer with pre-initialized fields. Auto
// generated.
func NewCoreConfigData() *CoreConfigData {
	return &CoreConfigData{}
}

// AssignLastInsertID updates the increment ID field with the last inserted ID
// from an INSERT operation. Implements dml.InsertIDAssigner. Auto generated.
func (e *CoreConfigData) AssignLastInsertID(id int64) {
	e.ConfigID = uint64(id)
}

// MapColumns implements interface ColumnMapper only partially. Auto generated.
func (e *CoreConfigData) MapColumns(cm *dml.ColumnMap) error {
	if cm.Mode() == dml.ColumnMapEntityReadAll {
		return cm.Uint64(&e.ConfigID).String(&e.Scope).Int64(&e.ScopeID).String(&e.Path).NullString(&e.Value).Err()
	}
	for cm.Next() {
		switch c := cm.Column(); c {
		case "config_id":
			cm.Uint64(&e.ConfigID)
		case "scope":
			cm.String(&e.Scope)
		case "scope_id":
			cm.Int64(&e.ScopeID)
		case "path", "storage_location", "config_directory":
			cm.String(&e.Path)
		case "value":
			cm.NullString(&e.Value)
		default:
			return errors.NotFound.Newf("[testdata] CoreConfigData Column %q not found", c)
		}
	}
	return errors.WithStack(cm.Err())
}

// experimental, for now private but depends on later usage to make it public.
type sliceCoreConfigData []*CoreConfigData

// CoreConfigDataCollection represents a collection type for DB table core_config_data
// Not thread safe. Auto generated.
type CoreConfigDataCollection struct {
	// Data contains a slice of []*CoreConfigData
	Data             sliceCoreConfigData
	BeforeMapColumns func(uint64, *CoreConfigData) error
	AfterMapColumns  func(uint64, *CoreConfigData) error
}

// MakeCoreConfigDataCollection creates a new initialized collection. Auto generated.
func MakeCoreConfigDataCollection() CoreConfigDataCollection {
	return CoreConfigDataCollection{
		Data: make(sliceCoreConfigData, 0, 5),
	}
}

func (cc CoreConfigDataCollection) scanColumns(cm *dml.ColumnMap, e *CoreConfigData, idx uint64) error {
	if err := cc.BeforeMapColumns(idx, e); err != nil {
		return errors.WithStack(err)
	}
	if err := e.MapColumns(cm); err != nil {
		return errors.WithStack(err)
	}
	if err := cc.AfterMapColumns(idx, e); err != nil {
		return errors.WithStack(err)
	}
	return nil
}

// MapColumns implements dml.ColumnMapper interface. Auto generated.
func (cc CoreConfigDataCollection) MapColumns(cm *dml.ColumnMap) error {
	switch m := cm.Mode(); m {
	case dml.ColumnMapEntityReadAll, dml.ColumnMapEntityReadSet:
		for i, e := range cc.Data {
			if err := cc.scanColumns(cm, e, uint64(i)); err != nil {
				return errors.WithStack(err)
			}
		}
	case dml.ColumnMapScan:
		if cm.Count == 0 {
			cc.Data = cc.Data[:0]
		}
		e := NewCoreConfigData()
		if err := cc.scanColumns(cm, e, cm.Count); err != nil {
			return errors.WithStack(err)
		}
		cc.Data = append(cc.Data, e)
	case dml.ColumnMapCollectionReadSet:
		for cm.Next() {
			switch c := cm.Column(); c {
			case "config_id":
				cm.Args = cm.Args.Uint64s(cc.ConfigIDs()...)
			case "path", "storage_location", "config_directory":
				cm.Args = cm.Args.Strings(cc.Paths()...)
			default:
				return errors.NotFound.Newf("[testdata] CoreConfigDataCollection Column %q not found", c)
			}
		}
	default:
		return errors.NotSupported.Newf("[dml] Unknown Mode: %q", string(m))
	}
	return cm.Err()
}

// ConfigIDs returns a slice or appends to a slice all values.
// Auto generated.
func (cc CoreConfigDataCollection) ConfigIDs(ret ...uint64) []uint64 {
	if ret == nil {
		ret = make([]uint64, 0, len(cc.Data))
	}
	for _, e := range cc.Data {
		ret = append(ret, e.ConfigID)
	}
	return ret
}

// Paths belongs to the column `path`
// and returns a slice or appends to a slice only unique values of that column.
// The values will be filtered internally in a Go map. No DB query gets
// executed. Auto generated.
func (cc CoreConfigDataCollection) Paths(ret ...string) []string {
	if ret == nil {
		ret = make([]string, 0, len(cc.Data))
	}

	dupCheck := make(map[string]struct{}, len(cc.Data))
	for _, e := range cc.Data {
		if _, ok := dupCheck[e.Path]; !ok {
			ret = append(ret, e.Path)
			dupCheck[e.Path] = struct{}{}
		}
	}
	return ret
}

// FilterThis filters the current slice by predicate f without memory allocation.
// Auto generated via dmlgen.
func (s sliceCoreConfigData) FilterThis(f func(*CoreConfigData) bool) sliceCoreConfigData {
	b := s[:0]
	for _, x := range s {
		if f(x) {
			b = append(b, x)
		}
	}
	return b
}

// Filter returns a new slice filtered by predicate f.
// Auto generated via dmlgen.
func (s sliceCoreConfigData) Filter(f func(*CoreConfigData) bool) sliceCoreConfigData {
	sl := make(sliceCoreConfigData, 0, len(s))
	for _, e := range s {
		if f(e) {
			sl = append(sl, e)
		}
	}
	return sl
}

// Each will run function f on all items in []*CoreConfigData.
// Auto generated via dmlgen.
func (s sliceCoreConfigData) Each(f func(*CoreConfigData)) sliceCoreConfigData {
	for i := range s {
		f(s[i])
	}
	return s
}

// Swap will satisfy the sort.Interface.
// Auto generated via dmlgen.
func (s sliceCoreConfigData) Swap(i, j int) { s[i], s[j] = s[j], s[i] }

// Cut will remove items i through j-1.
// Auto generated via dmlgen.
func (s *sliceCoreConfigData) Cut(i, j int) {
	z := *s // copy slice header
	copy(z[i:], z[j:])
	for k, n := len(z)-j+i, len(z); k < n; k++ {
		z[k] = nil // this should avoid the memory leak
	}
	z = z[:len(z)-j+i]
	*s = z
}

// Delete will remove an item from the slice.
// Auto generated via dmlgen.
func (s *sliceCoreConfigData) Delete(i int) {
	z := *s // copy the slice header
	end := len(z) - 1
	s.Swap(i, end)
	copy(z[i:], z[i+1:])
	z[end] = nil // this should avoid the memory leak
	z = z[:end]
	*s = z
}

// Insert will place a new item at position i.
// Auto generated via dmlgen.
func (s *sliceCoreConfigData) Insert(n *CoreConfigData, i int) {
	z := *s // copy the slice header
	z = append(z, &CoreConfigData{})
	copy(z[i+1:], z[i:])
	z[i] = n
	*s = z
}

// Append will add a new item at the end of sliceCoreConfigData.
// Auto generated via dmlgen.
func (s *sliceCoreConfigData) Append(n ...*CoreConfigData) {
	*s = append(*s, n...)
}

// Prepend will add a new item at the beginning of sliceCoreConfigData.
// Auto generated via dmlgen.
func (s *sliceCoreConfigData) Prepend(n *CoreConfigData) {
	s.Insert(n, 0)
}

// CustomerEntity represents a single row for DB table `customer_entity`.
// Auto generated.
type CustomerEntity struct {
	EntityID               uint64         // entity_id int(10) unsigned NOT NULL PRI  auto_increment "Entity Id"
	WebsiteID              dml.NullInt64  // website_id smallint(5) unsigned NULL MUL   "Website Id"
	Email                  dml.NullString // email varchar(255) NULL MUL   "Email"
	GroupID                uint64         // group_id smallint(5) unsigned NOT NULL  DEFAULT '0'  "Group Id"
	IncrementID            dml.NullString // increment_id varchar(50) NULL    "Increment Id"
	StoreID                dml.NullInt64  // store_id smallint(5) unsigned NULL MUL DEFAULT '0'  "Store Id"
	CreatedAt              time.Time      // created_at timestamp NOT NULL  DEFAULT 'current_timestamp()'  "Created At"
	UpdatedAt              time.Time      // updated_at timestamp NOT NULL  DEFAULT 'current_timestamp()' on update current_timestamp() "Updated At"
	IsActive               bool           // is_active smallint(5) unsigned NOT NULL  DEFAULT '1'  "Is Active"
	DisableAutoGroupChange uint64         // disable_auto_group_change smallint(5) unsigned NOT NULL  DEFAULT '0'  "Disable automatic group change based on VAT ID"
	CreatedIn              dml.NullString // created_in varchar(255) NULL    "Created From"
	Prefix                 dml.NullString // prefix varchar(40) NULL    "Name Prefix"
	Firstname              dml.NullString // firstname varchar(255) NULL MUL   "First Name"
	Middlename             dml.NullString // middlename varchar(255) NULL    "Middle Name/Initial"
	Lastname               dml.NullString // lastname varchar(255) NULL MUL   "Last Name"
	Suffix                 dml.NullString // suffix varchar(40) NULL    "Name Suffix"
	Dob                    dml.NullTime   // dob date NULL    "Date of Birth"
	PasswordHash           dml.NullString // password_hash varchar(128) NULL    "Password_hash"
	RpToken                dml.NullString // rp_token varchar(128) NULL    "Reset password token"
	RpTokenCreatedAt       dml.NullTime   // rp_token_created_at datetime NULL    "Reset password token creation time"
	DefaultBilling         dml.NullInt64  // default_billing int(10) unsigned NULL    "Default Billing Address"
	DefaultShipping        dml.NullInt64  // default_shipping int(10) unsigned NULL    "Default Shipping Address"
	Taxvat                 dml.NullString // taxvat varchar(50) NULL    "Tax/VAT Number"
	Confirmation           dml.NullString // confirmation varchar(64) NULL    "Is Confirmed"
	Gender                 dml.NullInt64  // gender smallint(5) unsigned NULL    "Gender"
	FailuresNum            dml.NullInt64  // failures_num smallint(6) NULL  DEFAULT '0'  "Failure Number"
	FirstFailure           dml.NullTime   // first_failure timestamp NULL    "First Failure"
	LockExpires            dml.NullTime   // lock_expires timestamp NULL    "Lock Expiration Date"
}

// NewCustomerEntity creates a new pointer with pre-initialized fields. Auto
// generated.
func NewCustomerEntity() *CustomerEntity {
	return &CustomerEntity{}
}

// AssignLastInsertID updates the increment ID field with the last inserted ID
// from an INSERT operation. Implements dml.InsertIDAssigner. Auto generated.
func (e *CustomerEntity) AssignLastInsertID(id int64) {
	e.EntityID = uint64(id)
}

// MapColumns implements interface ColumnMapper only partially. Auto generated.
func (e *CustomerEntity) MapColumns(cm *dml.ColumnMap) error {
	if cm.Mode() == dml.ColumnMapEntityReadAll {
		return cm.Uint64(&e.EntityID).NullInt64(&e.WebsiteID).NullString(&e.Email).Uint64(&e.GroupID).NullString(&e.IncrementID).NullInt64(&e.StoreID).Time(&e.CreatedAt).Time(&e.UpdatedAt).Bool(&e.IsActive).Uint64(&e.DisableAutoGroupChange).NullString(&e.CreatedIn).NullString(&e.Prefix).NullString(&e.Firstname).NullString(&e.Middlename).NullString(&e.Lastname).NullString(&e.Suffix).NullTime(&e.Dob).NullString(&e.PasswordHash).NullString(&e.RpToken).NullTime(&e.RpTokenCreatedAt).NullInt64(&e.DefaultBilling).NullInt64(&e.DefaultShipping).NullString(&e.Taxvat).NullString(&e.Confirmation).NullInt64(&e.Gender).NullInt64(&e.FailuresNum).NullTime(&e.FirstFailure).NullTime(&e.LockExpires).Err()
	}
	for cm.Next() {
		switch c := cm.Column(); c {
		case "entity_id", "customer_id", "parent_id":
			cm.Uint64(&e.EntityID)
		case "website_id":
			cm.NullInt64(&e.WebsiteID)
		case "email":
			cm.NullString(&e.Email)
		case "group_id":
			cm.Uint64(&e.GroupID)
		case "increment_id":
			cm.NullString(&e.IncrementID)
		case "store_id":
			cm.NullInt64(&e.StoreID)
		case "created_at":
			cm.Time(&e.CreatedAt)
		case "updated_at":
			cm.Time(&e.UpdatedAt)
		case "is_active":
			cm.Bool(&e.IsActive)
		case "disable_auto_group_change":
			cm.Uint64(&e.DisableAutoGroupChange)
		case "created_in":
			cm.NullString(&e.CreatedIn)
		case "prefix":
			cm.NullString(&e.Prefix)
		case "firstname":
			cm.NullString(&e.Firstname)
		case "middlename":
			cm.NullString(&e.Middlename)
		case "lastname":
			cm.NullString(&e.Lastname)
		case "suffix":
			cm.NullString(&e.Suffix)
		case "dob":
			cm.NullTime(&e.Dob)
		case "password_hash":
			cm.NullString(&e.PasswordHash)
		case "rp_token":
			cm.NullString(&e.RpToken)
		case "rp_token_created_at":
			cm.NullTime(&e.RpTokenCreatedAt)
		case "default_billing":
			cm.NullInt64(&e.DefaultBilling)
		case "default_shipping":
			cm.NullInt64(&e.DefaultShipping)
		case "taxvat":
			cm.NullString(&e.Taxvat)
		case "confirmation":
			cm.NullString(&e.Confirmation)
		case "gender":
			cm.NullInt64(&e.Gender)
		case "failures_num":
			cm.NullInt64(&e.FailuresNum)
		case "first_failure":
			cm.NullTime(&e.FirstFailure)
		case "lock_expires":
			cm.NullTime(&e.LockExpires)
		default:
			return errors.NotFound.Newf("[testdata] CustomerEntity Column %q not found", c)
		}
	}
	return errors.WithStack(cm.Err())
}

// experimental, for now private but depends on later usage to make it public.
type sliceCustomerEntity []*CustomerEntity

// CustomerEntityCollection represents a collection type for DB table customer_entity
// Not thread safe. Auto generated.
type CustomerEntityCollection struct {
	// Data contains a slice of []*CustomerEntity
	Data             sliceCustomerEntity
	BeforeMapColumns func(uint64, *CustomerEntity) error
	AfterMapColumns  func(uint64, *CustomerEntity) error
}

// MakeCustomerEntityCollection creates a new initialized collection. Auto generated.
func MakeCustomerEntityCollection() CustomerEntityCollection {
	return CustomerEntityCollection{
		Data: make(sliceCustomerEntity, 0, 5),
	}
}

func (cc CustomerEntityCollection) scanColumns(cm *dml.ColumnMap, e *CustomerEntity, idx uint64) error {
	if err := cc.BeforeMapColumns(idx, e); err != nil {
		return errors.WithStack(err)
	}
	if err := e.MapColumns(cm); err != nil {
		return errors.WithStack(err)
	}
	if err := cc.AfterMapColumns(idx, e); err != nil {
		return errors.WithStack(err)
	}
	return nil
}

// MapColumns implements dml.ColumnMapper interface. Auto generated.
func (cc CustomerEntityCollection) MapColumns(cm *dml.ColumnMap) error {
	switch m := cm.Mode(); m {
	case dml.ColumnMapEntityReadAll, dml.ColumnMapEntityReadSet:
		for i, e := range cc.Data {
			if err := cc.scanColumns(cm, e, uint64(i)); err != nil {
				return errors.WithStack(err)
			}
		}
	case dml.ColumnMapScan:
		if cm.Count == 0 {
			cc.Data = cc.Data[:0]
		}
		e := NewCustomerEntity()
		if err := cc.scanColumns(cm, e, cm.Count); err != nil {
			return errors.WithStack(err)
		}
		cc.Data = append(cc.Data, e)
	case dml.ColumnMapCollectionReadSet:
		for cm.Next() {
			switch c := cm.Column(); c {
			case "entity_id", "customer_id", "parent_id":
				cm.Args = cm.Args.Uint64s(cc.EntityIDs()...)
			default:
				return errors.NotFound.Newf("[testdata] CustomerEntityCollection Column %q not found", c)
			}
		}
	default:
		return errors.NotSupported.Newf("[dml] Unknown Mode: %q", string(m))
	}
	return cm.Err()
}

// EntityIDs returns a slice or appends to a slice all values.
// Auto generated.
func (cc CustomerEntityCollection) EntityIDs(ret ...uint64) []uint64 {
	if ret == nil {
		ret = make([]uint64, 0, len(cc.Data))
	}
	for _, e := range cc.Data {
		ret = append(ret, e.EntityID)
	}
	return ret
}

// FilterThis filters the current slice by predicate f without memory allocation.
// Auto generated via dmlgen.
func (s sliceCustomerEntity) FilterThis(f func(*CustomerEntity) bool) sliceCustomerEntity {
	b := s[:0]
	for _, x := range s {
		if f(x) {
			b = append(b, x)
		}
	}
	return b
}

// Filter returns a new slice filtered by predicate f.
// Auto generated via dmlgen.
func (s sliceCustomerEntity) Filter(f func(*CustomerEntity) bool) sliceCustomerEntity {
	sl := make(sliceCustomerEntity, 0, len(s))
	for _, e := range s {
		if f(e) {
			sl = append(sl, e)
		}
	}
	return sl
}

// Each will run function f on all items in []*CustomerEntity.
// Auto generated via dmlgen.
func (s sliceCustomerEntity) Each(f func(*CustomerEntity)) sliceCustomerEntity {
	for i := range s {
		f(s[i])
	}
	return s
}

// Swap will satisfy the sort.Interface.
// Auto generated via dmlgen.
func (s sliceCustomerEntity) Swap(i, j int) { s[i], s[j] = s[j], s[i] }

// Cut will remove items i through j-1.
// Auto generated via dmlgen.
func (s *sliceCustomerEntity) Cut(i, j int) {
	z := *s // copy slice header
	copy(z[i:], z[j:])
	for k, n := len(z)-j+i, len(z); k < n; k++ {
		z[k] = nil // this should avoid the memory leak
	}
	z = z[:len(z)-j+i]
	*s = z
}

// Delete will remove an item from the slice.
// Auto generated via dmlgen.
func (s *sliceCustomerEntity) Delete(i int) {
	z := *s // copy the slice header
	end := len(z) - 1
	s.Swap(i, end)
	copy(z[i:], z[i+1:])
	z[end] = nil // this should avoid the memory leak
	z = z[:end]
	*s = z
}

// Insert will place a new item at position i.
// Auto generated via dmlgen.
func (s *sliceCustomerEntity) Insert(n *CustomerEntity, i int) {
	z := *s // copy the slice header
	z = append(z, &CustomerEntity{})
	copy(z[i+1:], z[i:])
	z[i] = n
	*s = z
}

// Append will add a new item at the end of sliceCustomerEntity.
// Auto generated via dmlgen.
func (s *sliceCustomerEntity) Append(n ...*CustomerEntity) {
	*s = append(*s, n...)
}

// Prepend will add a new item at the beginning of sliceCustomerEntity.
// Auto generated via dmlgen.
func (s *sliceCustomerEntity) Prepend(n *CustomerEntity) {
	s.Insert(n, 0)
}

// UnmarshalJSON implements interface json.Unmarshaler.
func (cc *CustomerEntityCollection) UnmarshalJSON(b []byte) (err error) {
	return json.Unmarshal(b, cc.Data)
}

// MarshalJSON implements interface json.Marshaler.
func (cc *CustomerEntityCollection) MarshalJSON() ([]byte, error) {
	return json.Marshal(cc.Data)
}

// TODO add MarshalText and UnmarshalText.
// DmlgenTypes represents a single row for DB table `dmlgen_types`.
// Auto generated.
// Just another comment.
//easyjson:json
type DmlgenTypes struct {
	ID             int64          `json:"id,omitempty" `                // id int(11) NOT NULL PRI  auto_increment ""
	ColBigint1     dml.NullInt64  `json:"col_bigint_1,omitempty" `      // col_bigint_1 bigint(20) NULL    ""
	ColBigint2     int64          `json:"col_bigint_2,omitempty" `      // col_bigint_2 bigint(20) NOT NULL  DEFAULT '0'  ""
	ColBigint3     dml.NullInt64  `json:"col_bigint_3,omitempty" `      // col_bigint_3 bigint(20) unsigned NULL    ""
	ColBigint4     uint64         `json:"col_bigint_4,omitempty" `      // col_bigint_4 bigint(20) unsigned NOT NULL  DEFAULT '0'  ""
	ColBlob        dml.NullString `json:"col_blob,omitempty" `          // col_blob blob NULL    ""
	ColDate1       dml.NullTime   `json:"col_date_1,omitempty" `        // col_date_1 date NULL    ""
	ColDate2       time.Time      `json:"col_date_2,omitempty" `        // col_date_2 date NOT NULL  DEFAULT ''0000-00-00''  ""
	ColDatetime1   dml.NullTime   `json:"col_datetime_1,omitempty" `    // col_datetime_1 datetime NULL    ""
	ColDatetime2   time.Time      `json:"col_datetime_2,omitempty" `    // col_datetime_2 datetime NOT NULL  DEFAULT ''0000-00-00 00:00:00''  ""
	ColDecimal100  dml.Decimal    `json:"col_decimal_10_0,omitempty" `  // col_decimal_10_0 decimal(10,0) unsigned NULL    ""
	ColDecimal124  dml.Decimal    `json:"col_decimal_12_4,omitempty" `  // col_decimal_12_4 decimal(12,4) NULL    ""
	Price124a      dml.Decimal    `json:"price_12_4a,omitempty" `       // price_12_4a decimal(12,4) NULL    ""
	Price124b      dml.Decimal    `json:"price_12_4b,omitempty" `       // price_12_4b decimal(12,4) NOT NULL  DEFAULT '0.0000'  ""
	ColDecimal123  dml.Decimal    `json:"col_decimal_12_3,omitempty" `  // col_decimal_12_3 decimal(12,3) NOT NULL  DEFAULT '0.000'  ""
	ColDecimal206  dml.Decimal    `json:"col_decimal_20_6,omitempty" `  // col_decimal_20_6 decimal(20,6) NOT NULL  DEFAULT '0.000000'  ""
	ColDecimal2412 dml.Decimal    `json:"col_decimal_24_12,omitempty" ` // col_decimal_24_12 decimal(24,12) NOT NULL  DEFAULT '0.000000000000'  ""
	ColFloat       float64        `json:"col_float,omitempty" `         // col_float float NOT NULL  DEFAULT '1'  ""
	ColInt1        dml.NullInt64  `json:"col_int_1,omitempty" `         // col_int_1 int(10) NULL    ""
	ColInt2        int64          `json:"col_int_2,omitempty" `         // col_int_2 int(10) NOT NULL  DEFAULT '0'  ""
	ColInt3        dml.NullInt64  `json:"col_int_3,omitempty" `         // col_int_3 int(10) unsigned NULL    ""
	ColInt4        uint64         `json:"col_int_4,omitempty" `         // col_int_4 int(10) unsigned NOT NULL  DEFAULT '0'  ""
	ColLongtext1   dml.NullString `json:"col_longtext_1,omitempty" `    // col_longtext_1 longtext NULL    ""
	ColLongtext2   string         `json:"col_longtext_2,omitempty" `    // col_longtext_2 longtext NOT NULL  DEFAULT ''''  ""
	ColMediumblob  dml.NullString `json:"col_mediumblob,omitempty" `    // col_mediumblob mediumblob NULL    ""
	ColMediumtext1 dml.NullString `json:"col_mediumtext_1,omitempty" `  // col_mediumtext_1 mediumtext NULL    ""
	ColMediumtext2 string         `json:"col_mediumtext_2,omitempty" `  // col_mediumtext_2 mediumtext NOT NULL  DEFAULT ''''  ""
	ColSmallint1   dml.NullInt64  `json:"col_smallint_1,omitempty" `    // col_smallint_1 smallint(5) NULL    ""
	ColSmallint2   int64          `json:"col_smallint_2,omitempty" `    // col_smallint_2 smallint(5) NOT NULL  DEFAULT '0'  ""
	ColSmallint3   dml.NullInt64  `json:"col_smallint_3,omitempty" `    // col_smallint_3 smallint(5) unsigned NULL    ""
	ColSmallint4   uint64         `json:"col_smallint_4,omitempty" `    // col_smallint_4 smallint(5) unsigned NOT NULL  DEFAULT '0'  ""
	HasSmallint5   bool           `json:"has_smallint_5,omitempty" `    // has_smallint_5 smallint(5) unsigned NOT NULL  DEFAULT '0'  ""
	IsSmallint5    dml.NullBool   `json:"is_smallint_5,omitempty" `     // is_smallint_5 smallint(5) NULL    ""
	ColText        dml.NullString `json:"col_text,omitempty" `          // col_text text NULL    ""
	ColTimestamp1  time.Time      `json:"col_timestamp_1,omitempty" `   // col_timestamp_1 timestamp NOT NULL  DEFAULT 'current_timestamp()'  ""
	ColTimestamp2  dml.NullTime   `json:"col_timestamp_2,omitempty" `   // col_timestamp_2 timestamp NULL    ""
	ColTinyint1    int64          `json:"col_tinyint_1,omitempty" `     // col_tinyint_1 tinyint(1) NOT NULL  DEFAULT '0'  ""
	ColVarchar1    string         `json:"col_varchar_1,omitempty" `     // col_varchar_1 varchar(1) NOT NULL  DEFAULT ''0''  ""
	ColVarchar100  dml.NullString `json:"col_varchar_100,omitempty" `   // col_varchar_100 varchar(100) NULL    ""
	ColVarchar16   string         `json:"col_varchar_16,omitempty" `    // col_varchar_16 varchar(16) NOT NULL  DEFAULT ''de_DE''  ""
	ColChar1       dml.NullString `json:"col_char_1,omitempty" `        // col_char_1 char(21) NULL    ""
	ColChar2       string         `json:"col_char_2,omitempty" `        // col_char_2 char(17) NOT NULL  DEFAULT ''xchar''  ""
}

// NewDmlgenTypes creates a new pointer with pre-initialized fields. Auto
// generated.
func NewDmlgenTypes() *DmlgenTypes {
	return &DmlgenTypes{}
}

// AssignLastInsertID updates the increment ID field with the last inserted ID
// from an INSERT operation. Implements dml.InsertIDAssigner. Auto generated.
func (e *DmlgenTypes) AssignLastInsertID(id int64) {
	e.ID = int64(id)
}

// MapColumns implements interface ColumnMapper only partially. Auto generated.
func (e *DmlgenTypes) MapColumns(cm *dml.ColumnMap) error {
	if cm.Mode() == dml.ColumnMapEntityReadAll {
		return cm.Int64(&e.ID).NullInt64(&e.ColBigint1).Int64(&e.ColBigint2).NullInt64(&e.ColBigint3).Uint64(&e.ColBigint4).NullString(&e.ColBlob).NullTime(&e.ColDate1).Time(&e.ColDate2).NullTime(&e.ColDatetime1).Time(&e.ColDatetime2).Decimal(&e.ColDecimal100).Decimal(&e.ColDecimal124).Decimal(&e.Price124a).Decimal(&e.Price124b).Decimal(&e.ColDecimal123).Decimal(&e.ColDecimal206).Decimal(&e.ColDecimal2412).Float64(&e.ColFloat).NullInt64(&e.ColInt1).Int64(&e.ColInt2).NullInt64(&e.ColInt3).Uint64(&e.ColInt4).NullString(&e.ColLongtext1).String(&e.ColLongtext2).NullString(&e.ColMediumblob).NullString(&e.ColMediumtext1).String(&e.ColMediumtext2).NullInt64(&e.ColSmallint1).Int64(&e.ColSmallint2).NullInt64(&e.ColSmallint3).Uint64(&e.ColSmallint4).Bool(&e.HasSmallint5).NullBool(&e.IsSmallint5).NullString(&e.ColText).Time(&e.ColTimestamp1).NullTime(&e.ColTimestamp2).Int64(&e.ColTinyint1).String(&e.ColVarchar1).NullString(&e.ColVarchar100).String(&e.ColVarchar16).NullString(&e.ColChar1).String(&e.ColChar2).Err()
	}
	for cm.Next() {
		switch c := cm.Column(); c {
		case "id":
			cm.Int64(&e.ID)
		case "col_bigint_1":
			cm.NullInt64(&e.ColBigint1)
		case "col_bigint_2":
			cm.Int64(&e.ColBigint2)
		case "col_bigint_3":
			cm.NullInt64(&e.ColBigint3)
		case "col_bigint_4":
			cm.Uint64(&e.ColBigint4)
		case "col_blob":
			cm.NullString(&e.ColBlob)
		case "col_date_1":
			cm.NullTime(&e.ColDate1)
		case "col_date_2":
			cm.Time(&e.ColDate2)
		case "col_datetime_1":
			cm.NullTime(&e.ColDatetime1)
		case "col_datetime_2":
			cm.Time(&e.ColDatetime2)
		case "col_decimal_10_0":
			cm.Decimal(&e.ColDecimal100)
		case "col_decimal_12_4":
			cm.Decimal(&e.ColDecimal124)
		case "price_12_4a":
			cm.Decimal(&e.Price124a)
		case "price_12_4b":
			cm.Decimal(&e.Price124b)
		case "col_decimal_12_3":
			cm.Decimal(&e.ColDecimal123)
		case "col_decimal_20_6":
			cm.Decimal(&e.ColDecimal206)
		case "col_decimal_24_12":
			cm.Decimal(&e.ColDecimal2412)
		case "col_float":
			cm.Float64(&e.ColFloat)
		case "col_int_1":
			cm.NullInt64(&e.ColInt1)
		case "col_int_2":
			cm.Int64(&e.ColInt2)
		case "col_int_3":
			cm.NullInt64(&e.ColInt3)
		case "col_int_4":
			cm.Uint64(&e.ColInt4)
		case "col_longtext_1":
			cm.NullString(&e.ColLongtext1)
		case "col_longtext_2":
			cm.String(&e.ColLongtext2)
		case "col_mediumblob":
			cm.NullString(&e.ColMediumblob)
		case "col_mediumtext_1":
			cm.NullString(&e.ColMediumtext1)
		case "col_mediumtext_2":
			cm.String(&e.ColMediumtext2)
		case "col_smallint_1":
			cm.NullInt64(&e.ColSmallint1)
		case "col_smallint_2":
			cm.Int64(&e.ColSmallint2)
		case "col_smallint_3":
			cm.NullInt64(&e.ColSmallint3)
		case "col_smallint_4":
			cm.Uint64(&e.ColSmallint4)
		case "has_smallint_5":
			cm.Bool(&e.HasSmallint5)
		case "is_smallint_5":
			cm.NullBool(&e.IsSmallint5)
		case "col_text":
			cm.NullString(&e.ColText)
		case "col_timestamp_1":
			cm.Time(&e.ColTimestamp1)
		case "col_timestamp_2":
			cm.NullTime(&e.ColTimestamp2)
		case "col_tinyint_1":
			cm.Int64(&e.ColTinyint1)
		case "col_varchar_1":
			cm.String(&e.ColVarchar1)
		case "col_varchar_100":
			cm.NullString(&e.ColVarchar100)
		case "col_varchar_16":
			cm.String(&e.ColVarchar16)
		case "col_char_1":
			cm.NullString(&e.ColChar1)
		case "col_char_2":
			cm.String(&e.ColChar2)
		default:
			return errors.NotFound.Newf("[testdata] DmlgenTypes Column %q not found", c)
		}
	}
	return errors.WithStack(cm.Err())
}

// experimental, for now private but depends on later usage to make it public.
type sliceDmlgenTypes []*DmlgenTypes

// DmlgenTypesCollection represents a collection type for DB table dmlgen_types
// Not thread safe. Auto generated.
// Just another comment.
//easyjson:json
type DmlgenTypesCollection struct {
	// Data contains a slice of []*DmlgenTypes
	Data             sliceDmlgenTypes
	BeforeMapColumns func(uint64, *DmlgenTypes) error
	AfterMapColumns  func(uint64, *DmlgenTypes) error
}

// MakeDmlgenTypesCollection creates a new initialized collection. Auto generated.
func MakeDmlgenTypesCollection() DmlgenTypesCollection {
	return DmlgenTypesCollection{
		Data: make(sliceDmlgenTypes, 0, 5),
	}
}

func (cc DmlgenTypesCollection) scanColumns(cm *dml.ColumnMap, e *DmlgenTypes, idx uint64) error {
	if err := cc.BeforeMapColumns(idx, e); err != nil {
		return errors.WithStack(err)
	}
	if err := e.MapColumns(cm); err != nil {
		return errors.WithStack(err)
	}
	if err := cc.AfterMapColumns(idx, e); err != nil {
		return errors.WithStack(err)
	}
	return nil
}

// MapColumns implements dml.ColumnMapper interface. Auto generated.
func (cc DmlgenTypesCollection) MapColumns(cm *dml.ColumnMap) error {
	switch m := cm.Mode(); m {
	case dml.ColumnMapEntityReadAll, dml.ColumnMapEntityReadSet:
		for i, e := range cc.Data {
			if err := cc.scanColumns(cm, e, uint64(i)); err != nil {
				return errors.WithStack(err)
			}
		}
	case dml.ColumnMapScan:
		if cm.Count == 0 {
			cc.Data = cc.Data[:0]
		}
		e := NewDmlgenTypes()
		if err := cc.scanColumns(cm, e, cm.Count); err != nil {
			return errors.WithStack(err)
		}
		cc.Data = append(cc.Data, e)
	case dml.ColumnMapCollectionReadSet:
		for cm.Next() {
			switch c := cm.Column(); c {
			case "id":
				cm.Args = cm.Args.Int64s(cc.IDs()...)
			case "col_blob":
				cm.Args = cm.Args.Strings(cc.ColBlobs()...)
			case "col_date_2":
				cm.Args = cm.Args.Times(cc.ColDate2s()...)
			case "col_int_1":
				cm.Args = cm.Args.Int64s(cc.ColInt1s()...)
			case "col_int_2":
				cm.Args = cm.Args.Int64s(cc.ColInt2s()...)
			case "col_longtext_2":
				cm.Args = cm.Args.Strings(cc.ColLongtext2s()...)
			case "has_smallint_5":
				cm.Args = cm.Args.Bools(cc.HasSmallint5s()...)
			default:
				return errors.NotFound.Newf("[testdata] DmlgenTypesCollection Column %q not found", c)
			}
		}
	default:
		return errors.NotSupported.Newf("[dml] Unknown Mode: %q", string(m))
	}
	return cm.Err()
}

// IDs returns a slice or appends to a slice all values.
// Auto generated.
func (cc DmlgenTypesCollection) IDs(ret ...int64) []int64 {
	if ret == nil {
		ret = make([]int64, 0, len(cc.Data))
	}
	for _, e := range cc.Data {
		ret = append(ret, e.ID)
	}
	return ret
}

// ColBlobs belongs to the column `col_blob`
// and returns a slice or appends to a slice only unique values of that column.
// The values will be filtered internally in a Go map. No DB query gets
// executed. Auto generated.
func (cc DmlgenTypesCollection) ColBlobs(ret ...string) []string {
	if ret == nil {
		ret = make([]string, 0, len(cc.Data))
	}

	dupCheck := make(map[string]struct{}, len(cc.Data))
	for _, e := range cc.Data {
		if _, ok := dupCheck[e.ColBlob.String]; !ok {
			ret = append(ret, e.ColBlob.String)
			dupCheck[e.ColBlob.String] = struct{}{}
		}
	}
	return ret
}

// ColDate2s belongs to the column `col_date_2`
// and returns a slice or appends to a slice only unique values of that column.
// The values will be filtered internally in a Go map. No DB query gets
// executed. Auto generated.
func (cc DmlgenTypesCollection) ColDate2s(ret ...time.Time) []time.Time {
	if ret == nil {
		ret = make([]time.Time, 0, len(cc.Data))
	}

	dupCheck := make(map[time.Time]struct{}, len(cc.Data))
	for _, e := range cc.Data {
		if _, ok := dupCheck[e.ColDate2]; !ok {
			ret = append(ret, e.ColDate2)
			dupCheck[e.ColDate2] = struct{}{}
		}
	}
	return ret
}

// ColInt1s belongs to the column `col_int_1`
// and returns a slice or appends to a slice only unique values of that column.
// The values will be filtered internally in a Go map. No DB query gets
// executed. Auto generated.
func (cc DmlgenTypesCollection) ColInt1s(ret ...int64) []int64 {
	if ret == nil {
		ret = make([]int64, 0, len(cc.Data))
	}

	dupCheck := make(map[int64]struct{}, len(cc.Data))
	for _, e := range cc.Data {
		if _, ok := dupCheck[e.ColInt1.Int64]; !ok {
			ret = append(ret, e.ColInt1.Int64)
			dupCheck[e.ColInt1.Int64] = struct{}{}
		}
	}
	return ret
}

// ColInt2s belongs to the column `col_int_2`
// and returns a slice or appends to a slice only unique values of that column.
// The values will be filtered internally in a Go map. No DB query gets
// executed. Auto generated.
func (cc DmlgenTypesCollection) ColInt2s(ret ...int64) []int64 {
	if ret == nil {
		ret = make([]int64, 0, len(cc.Data))
	}

	dupCheck := make(map[int64]struct{}, len(cc.Data))
	for _, e := range cc.Data {
		if _, ok := dupCheck[e.ColInt2]; !ok {
			ret = append(ret, e.ColInt2)
			dupCheck[e.ColInt2] = struct{}{}
		}
	}
	return ret
}

// ColLongtext2s belongs to the column `col_longtext_2`
// and returns a slice or appends to a slice only unique values of that column.
// The values will be filtered internally in a Go map. No DB query gets
// executed. Auto generated.
func (cc DmlgenTypesCollection) ColLongtext2s(ret ...string) []string {
	if ret == nil {
		ret = make([]string, 0, len(cc.Data))
	}

	dupCheck := make(map[string]struct{}, len(cc.Data))
	for _, e := range cc.Data {
		if _, ok := dupCheck[e.ColLongtext2]; !ok {
			ret = append(ret, e.ColLongtext2)
			dupCheck[e.ColLongtext2] = struct{}{}
		}
	}
	return ret
}

// HasSmallint5s belongs to the column `has_smallint_5`
// and returns a slice or appends to a slice only unique values of that column.
// The values will be filtered internally in a Go map. No DB query gets
// executed. Auto generated.
func (cc DmlgenTypesCollection) HasSmallint5s(ret ...bool) []bool {
	if ret == nil {
		ret = make([]bool, 0, len(cc.Data))
	}

	dupCheck := make(map[bool]struct{}, len(cc.Data))
	for _, e := range cc.Data {
		if _, ok := dupCheck[e.HasSmallint5]; !ok {
			ret = append(ret, e.HasSmallint5)
			dupCheck[e.HasSmallint5] = struct{}{}
		}
	}
	return ret
}

// FilterThis filters the current slice by predicate f without memory allocation.
// Auto generated via dmlgen.
func (s sliceDmlgenTypes) FilterThis(f func(*DmlgenTypes) bool) sliceDmlgenTypes {
	b := s[:0]
	for _, x := range s {
		if f(x) {
			b = append(b, x)
		}
	}
	return b
}

// Filter returns a new slice filtered by predicate f.
// Auto generated via dmlgen.
func (s sliceDmlgenTypes) Filter(f func(*DmlgenTypes) bool) sliceDmlgenTypes {
	sl := make(sliceDmlgenTypes, 0, len(s))
	for _, e := range s {
		if f(e) {
			sl = append(sl, e)
		}
	}
	return sl
}

// Each will run function f on all items in []*DmlgenTypes.
// Auto generated via dmlgen.
func (s sliceDmlgenTypes) Each(f func(*DmlgenTypes)) sliceDmlgenTypes {
	for i := range s {
		f(s[i])
	}
	return s
}

// Swap will satisfy the sort.Interface.
// Auto generated via dmlgen.
func (s sliceDmlgenTypes) Swap(i, j int) { s[i], s[j] = s[j], s[i] }

// Cut will remove items i through j-1.
// Auto generated via dmlgen.
func (s *sliceDmlgenTypes) Cut(i, j int) {
	z := *s // copy slice header
	copy(z[i:], z[j:])
	for k, n := len(z)-j+i, len(z); k < n; k++ {
		z[k] = nil // this should avoid the memory leak
	}
	z = z[:len(z)-j+i]
	*s = z
}

// Delete will remove an item from the slice.
// Auto generated via dmlgen.
func (s *sliceDmlgenTypes) Delete(i int) {
	z := *s // copy the slice header
	end := len(z) - 1
	s.Swap(i, end)
	copy(z[i:], z[i+1:])
	z[end] = nil // this should avoid the memory leak
	z = z[:end]
	*s = z
}

// Insert will place a new item at position i.
// Auto generated via dmlgen.
func (s *sliceDmlgenTypes) Insert(n *DmlgenTypes, i int) {
	z := *s // copy the slice header
	z = append(z, &DmlgenTypes{})
	copy(z[i+1:], z[i:])
	z[i] = n
	*s = z
}

// Append will add a new item at the end of sliceDmlgenTypes.
// Auto generated via dmlgen.
func (s *sliceDmlgenTypes) Append(n ...*DmlgenTypes) {
	*s = append(*s, n...)
}

// Prepend will add a new item at the beginning of sliceDmlgenTypes.
// Auto generated via dmlgen.
func (s *sliceDmlgenTypes) Prepend(n *DmlgenTypes) {
	s.Insert(n, 0)
}

// UnmarshalJSON implements interface json.Unmarshaler.
func (cc *DmlgenTypesCollection) UnmarshalJSON(b []byte) (err error) {
	return json.Unmarshal(b, cc.Data)
}

// MarshalJSON implements interface json.Marshaler.
func (cc *DmlgenTypesCollection) MarshalJSON() ([]byte, error) {
	return json.Marshal(cc.Data)
}

// TODO add MarshalText and UnmarshalText.
// UnmarshalBinary implements encoding.BinaryUnmarshaler.
func (cc *DmlgenTypesCollection) UnmarshalBinary(data []byte) error {
	return cc.Unmarshal(data) // Implemented via github.com/gogo/protobuf
}

// MarshalBinary implements encoding.BinaryMarshaler.
func (cc *DmlgenTypesCollection) MarshalBinary() (data []byte, err error) {
	return cc.Marshal() // Implemented via github.com/gogo/protobuf
}

// GobDecode kept for Go 1 compatibility reasons.
// deprecated in Go 2, use UnmarshalBinary
func (cc *DmlgenTypesCollection) GobDecode(data []byte) error {
	return cc.Unmarshal(data) // Implemented via github.com/gogo/protobuf
}

// GobEncode kept for Go 1 compatibility reasons.
// deprecated in Go 2, use MarshalBinary
func (cc *DmlgenTypesCollection) GobEncode() ([]byte, error) {
	return cc.Marshal() // Implemented via github.com/gogo/protobuf
}
